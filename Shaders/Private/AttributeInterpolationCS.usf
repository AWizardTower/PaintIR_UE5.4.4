// 缺少Platform.ush将导致crash。
#include "/Engine/Public/Platform.ush"

// 原来可以用cbuffer
//cbuffer InterpolationSettings : register(b0)
//{
	int NumKeyPoints;
	float3 BoxExtent; // 用于反归一化相对坐标
//}

// float minVal;
// float maxVal; // 你的插值值的理论最大值范围
// uint VertexCount;  // 缓冲区的长度


//float3 BoxExtent;
// 包围盒最小值与最大值

//	float3 MinBound;
//	float3 MaxBound;+522

// 包围盒最小值与最大值

//	uint TextureWidth;  // 纹理的实际宽度
//	uint TextureHeight; // 纹理的实际高度

Texture2D<float4> InputTexture : register(t0); // 来自 RenderTarget 的内容
StructuredBuffer<float4> KeyPositions : register(t1); // xyz = 位置, w = 值
// StructuredBuffer<float3> VertexPositions : register(t0);
// StructuredBuffer<float2> VertexUVs : register(t1);
RWTexture2D<float4> OutputTexture : register(u0);

// 控制渐变的参数
float BrushStrength = 1.0;  // 笔刷强度
float MaxBrushDistance = 1.0; // 最大影响距离，定义渐变范围

[numthreads(8, 8, 1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
	// 获取当前像素的坐标
	uint2 uv = DTid.xy;
	// 从输入纹理中读取归一化坐标，反归一化回世界坐标
	float4 encoded = InputTexture.Load(int3(uv, 0));
	float3 WorldPos = (encoded.rgb - 0.5) * BoxExtent;

	// 判断是否为纯黑背景（认为黑背景为无效像素）
	if (all(encoded.rgb == float3(0, 0, 0)))
	{
		OutputTexture[uv] = float4(1, 1, 1, 0); // 或者不写入（保持原值），看你需求
		return;
	}

	// 初始化渐变目标颜色（比如可以是一个固定的目标颜色，或者根据情况动态设置）
	float3 targetColor = float3(1, 1, 1);  // 目标颜色是红色
	float3 baseColor = float3(0, 0, 0);

	// 遍历关键点，判断哪些像素应该应用渐变
	for (int i = 0; i < NumKeyPoints; ++i)
	{
		// 判断当前像素是否在关键点的影响范围内
		float dist = distance(WorldPos, KeyPositions[i].xyz);
        
		if (dist < 10.0)  // 设定影响范围的半径
		{
			// 计算渐变比例，根据距离插值
			float weight = saturate(1.0 - dist / 10.0);  // 范围[0, 1]的渐变

			// 使用渐变比例平滑过渡到目标颜色
			float3 newColor = lerp(baseColor, targetColor, weight);

			// 写入渐变后的颜色
			OutputTexture[uv] = float4(newColor, 1.0);
			return;
		}
	}

	// 如果不在关键点影响范围内，则保持原始颜色
	OutputTexture[uv] = encoded;
}